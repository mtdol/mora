module excluding () {
    op :  := Cons;
}

data List a := 
      Cons ({lgetVal, lsetVal} :: a) ({lgetNext, lsetNext} :: List a)
    | Null
;


fn null v {return v = Null;}

--lsingleton :: a -> List a;
fn lsingleton x {return Cons x Null;}

fn head v {return
    if null v then 
        error "`head`: Cannot deref Null."
    else
        lgetVal v
;}

fn tail v {return
    if null v then 
        error "`tail`: Cannot deref Null."
    else
        lgetNext v
;}

fn maybeHead v {return
    case v {
        Null -> No;
        x:_ -> Yes x;
    }
;}

fn maybeTail v {return
    case v {
        Null -> No;
        _:xs -> Yes xs;
    }
;}

fn lindex xs i {return
    case xs {
        Null -> error "lindex: Index out of bounds.";
        x:xs -> 
            if i = 0 then x else lindex xs (i-1);
    }
;}

--lappend :: List a -> List a -> List a;
fn lappend xs ys {return
    -- `,` is tuple constructor
    -- `case` is an expression, `Case` is a statement
    case (xs, ys) {
        (Null, ys) -> 
            ys;
        ((x:xs), ys) ->
            Cons x (xs `lappend` ys);
    }
;}

fn lfilter f xs {return
    case xs {
        x:xs -> if f x then x : lfilter f xs else lfilter f xs;
        Null -> Null;
    }
;}

-- TODO: test this
--lreverse :: List a -> List a;
fn lreverse xs {
    fn aux xs acc {return
        case xs {
            Null -> acc;
            x:xs -> aux xs (x:acc);
        }
    ;}

    return aux xs Null;
}

-- generative map
--lgmap :: (a -> b) -> List a -> List b;
fn lgmap f xs {return
    case xs {
        Null -> Null;
        x:xs -> f x : f `lgmap` xs;
    }
;}

-- in-place map
--lmap :: (a -> b) -> List a -> Void;
fn lmap f xs {
    Case xs {
        Null -> {}
        xs_@x:xs -> {
            lsetVal xs_ $ f x;
            lmap f xs;
        }
    }
}

fn lzip xs ys {return
    case (xs,ys) {
        (Null,_) -> Null;
        (_,Null) -> Null;
        ((x:xs),(y:ys)) -> (x,y) : lzip xs ys;
    }
;}

fn llength xs {return
    case xs {
        Null -> 0;
        _:xs -> 1 + llength xs;
    }   
;}

fn arrayToList a {
    dec i <- length a - 1;
    dec ret <- Null;

    While i /= -1 {
        ret <- a ! i : ret;
        i -< 1;
    }

    return ret;
}

fn listToArray xs {
    dec ret <- Array $ llength xs;
    dec i <- 0;

    While xs /= Null {
        ret ! i <- head xs;
        i +< 1;
        xs <- tail xs;
    }

    return ret;
}

fn lprint xs {
    Case xs {
        x:xs -> {print x; put " : "; lprint xs;}
        Null -> {put "Null";}
    }
}

fn lprintLn xs {lprint xs; putLn "";}
