module excluding () {
    op ++   append;
    op :    Cons;
}

data Maybe a := 
      Yes ({getMaybe} :: a)  
    | No
;
data Either a b := 
      Left ({getLeft} :: a) 
    | Right ({getRight} :: b)
;

-- generic heap reference
data Box a := Box ({unbox,setbox} :: a);

type String := Array Char;

-- id :: a -> a;
fn id a -> a;

--not :: Bool -> Bool;
fn not b -> if b then False else True;

--xor :: Bool -> Bool -> Bool;
fn xor b1 b2 -> b1 /= b2;

--
--- Basic Math
--

fn odd n -> n % 2 = 1;
fn even n -> n % 2 = 0;
fn add1 n -> n+1;
fn sub1 n -> n-1;

fn max n1 n2 -> if n1 >= n2 then n1 else n2;
fn min n1 n2 -> if n1 <= n2 then n1 else n2;

--inRange :: (Int,Int) -> Int;
fn inRange r x -> x >= fst r && x < snd r;

-- in place map
--map :: (a -> b) -> Array a -> Void;
fn map f a {
    dec i;
    i <- 0;

    While (i /= length a) {
        a ! i <- f (a ! i);
        i +< 1;
    }
}

-- map and generate a new array
-- "generative" map
--map :: (a -> b) -> Array a -> Array b;
fn gmap f a {
    dec i, ret;
    i <- 0;
    ret <- Array $ length a;

    While i /= length a {
        ret ! i <- f (a ! i);
        i +< 1;
    }

    return ret;
}

-- applies a function to an array without modifying it.
-- "void" map
--vmap :: (a -> b) -> Array a -> Void;
fn vmap f a {
    dec i;
    i <- 0;

    While i /= length a {
        f $ a ! i;
        i +< 1;
    }
}

fn index a i -> a ! i;
fn setArray a i v {a ! i <- v;}

--append :: Array a -> Array a -> Array a;
fn append a1 a2 {
    dec ret, i;
    ret <- Array $ length a1 + length a2;
    i <- 0;

    While i /= length a1 {
        ret ! i <- a1 ! i;
        i     +< 1;
    }

    While i /= length ret {
        ret ! i <- a2 ! (i - length a1);
        i     +< 1;
    }

    return ret;
}

--filter :: (a -> Bool) -> Array a -> Array a;
fn filter f a {
    dec ret, i, reti, ret2;
    ret     <- Array $ length a;
    i       <- 0;
    reti    <- 0;

    While i /= length a {
        If f $ a ! i {
            ret ! reti <- a ! i;
            reti     +< 1;
        }
        i +< 1;
    }

    -- shrink array
    i <- 0;
    ret2 <- Array reti;
    While i /= reti {ret2 ! i <- ret ! i; i +< 1;}

    return ret2;
}


fn elem a e {
    dec i <- 0;

    While i /= length a {
        If a ! i = e {return True;}
        i +< 1;
    }

    return False;
}

--slice :: Array a -> (Int, Int) -> Array a
fn slice a is {
    dec ret, reti, i1, i2;
    i1 <- fst is;
    i2 <- snd is;
    reti <- 0;

    If i1 > i2 || i2 - i1 > length a {
        error $ "Invalid range for slice: [" 
            ++ show i1 ++ " " ++ show i2 ++ ")";
    }
    ret <- Array $ i2 - i1;
    
    While i1 /= i2 {
        ret ! reti <- a ! i1;
        reti  +< 1;
        i1 +< 1;
    }

    return ret;
}

-- zip :: Array a -> Array b -> Array (a,b)
fn zip xs ys {
    dec l <- min (length xs) (length ys);
    dec ret <- Array l;
    dec i <- 0;

    While i /= l {
        ret ! i <- (xs ! i, ys ! i);
        i +< 1;
    }

    return ret;
}

--
--- Strings
--

--toUpper :: String -> String;
fn toUpper s ->
    \c -> (
        if inRange (97,122) (ord c) then
            chr $ ord c - 32
        else c
    ) `gmap` s
;



--
--- IO
--

fn retPrint v {printLn v; return v;}

--print :: a -> Void;
fn print v {put $ show v;}
--printLn :: a -> Void;
fn printLn v {putLn $ show v;}

-- prints strings
fn put s {printChar `vmap` s;}
fn putLn s {printChar `vmap` s; printChar '\n';}


-- Works, but is very literal.
-- Chokes on trailing whitespace and negative sign.
-- readInt :: String -> Maybe Int;
fn readInt s {
    dec i <- length s - 1;
    dec j <- 0;
    dec n <- 0;
    dec c <- 0;

    -- [48,57]
    While i /= -1 {
        c <- ord $ s ! i;
        If c > 57 || c < 48 {
            return No;
        } Else {
            c <- c - 48;
            n <- n + (10**j * c);

        }

        i -< 1;
        j +< 1;
    }

    return Yes n;
}

--
--- Structures, Tuples
--

fn fst tp ->
    case tp {
        (x,_) -> x;
    }
;

fn snd tp ->
    case tp {
        (_,y) -> y;
    }
;

-- uncurry :: (a -> b -> c) -> (a, b) -> c;
fn uncurry f xy ->
    f (fst xy) (snd xy)
;

-- curry :: ((a, b) -> c) -> a -> b -> c;
fn curry f x y ->
    f (x,y)
;


--
-- List
-- 

data List a := 
      Cons ({lgetVal, lsetVal} :: a) ({lgetNext, lsetNext} :: List a)
    | Null
;


fn null v -> v = Null;

--lsingleton :: a -> List a;
fn lsingleton x -> Cons x Null;

fn head v ->
    if null v then 
        error "`head`: Cannot deref Null."
    else
        lgetVal v
;

fn tail v ->
    if null v then 
        error "`tail`: Cannot deref Null."
    else
        lgetNext v
;

fn maybeHead v ->
    case v {
        Null -> No;
        x:_ -> Yes x;
    }
;

fn maybeTail v ->
    case v {
        Null -> No;
        _:xs -> Yes xs;
    }
;

fn lindex xs i ->
    case xs {
        Null -> error "lindex: Index out of bounds.";
        x:xs -> 
            if i = 0 then x else lindex xs (i-1);
    }
;

--lappend :: List a -> List a -> List a;
fn lappend xs ys ->
    -- `,` is tuple constructor
    -- `case` is an expression, `Case` is a statement
    case (xs, ys) {
        (Null, ys) -> 
            ys;
        ((x:xs), ys) ->
            Cons x (xs `lappend` ys);
    }
;

fn lfilter f xs -> case xs {
        x:xs -> if f x then x : lfilter f xs else lfilter f xs;
        Null -> Null;
};

fn lelem xs e -> case xs {
    Null -> False;
    x:xs -> if x = e then True else lelem xs e;
};

-- TODO: test this
--lreverse :: List a -> List a;
fn lreverse xs {
    fn aux xs acc ->
        case xs {
            Null -> acc;
            x:xs -> aux xs (x:acc);
        }
    ;

    return aux xs Null;
}

-- generative map
--lgmap :: (a -> b) -> List a -> List b;
fn lgmap f xs ->
    case xs {
        Null -> Null;
        x:xs -> f x : f `lgmap` xs;
    }
;

-- in-place map
--lmap :: (a -> b) -> List a -> Void;
fn lmap f xs {
    Case xs {
        Null -> {}
        xs_@x:xs -> {
            lsetVal xs_ $ f x;
            lmap f xs;
        }
    }
}

-- void map
--lvmap :: (a -> b) -> List a -> Void;
fn lvmap f xs {
    Case xs {
        Null -> {}
        x:xs -> {f x; f `lvmap` xs;}
    }
}

fn lzip xs ys ->
    case (xs,ys) {
        (Null,_) -> Null;
        (_,Null) -> Null;
        ((x:xs),(y:ys)) -> (x,y) : lzip xs ys;
    }
;

fn llength xs ->
    case xs {
        Null -> 0;
        _:xs -> 1 + llength xs;
    }
;

fn arrayToList a {
    dec i <- length a - 1;
    dec ret <- Null;

    While i /= -1 {
        ret <- a ! i : ret;
        i -< 1;
    }

    return ret;
}

fn listToArray xs {
    dec ret <- Array $ llength xs;
    dec i <- 0;

    While xs /= Null {
        ret ! i <- head xs;
        i +< 1;
        xs <- tail xs;
    }

    return ret;
}

-- list pretty print
fn lprint xs {
    Case xs {
        x:xs -> {print x; put " : "; lprint xs;}
        Null -> {put "Null";}
    }
}

fn lprintLn xs {lprint xs; putLn "";}
