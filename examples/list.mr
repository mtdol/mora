-- free types (`a` here) must be quantified on the left
data List a := 
      Cons val :: a, next :: List a
    | Null
;

singleton :: a -> List a;
fn singleton x {return Cons x Null;}

-- defines `:` as the `cons` operator
-- tokens like `:` are always infix ops
fn : x xs {return Cons x xs;}

append :: List a -> List a -> List a;
fn append xs ys {return
    -- `,` is tuple constructor
    -- `case` is an expression, `Case` is a statement
    case xs, ys {
        Null, ys -> 
            ys;
        (x:xs), ys ->
            Cons x (xs `append` ys);
    }
;}

head :: List a -> a;
fn head xs {
    If xs = Null {error "Cannot head deref Null."}
    Else {return xs.val;}
}

tail :: List a -> List a;
fn tail xs {
    If xs = Null {error "Cannot tail deref Null.";}
    Else {return xs.next}
}

reverse :: List a -> List a;
fn reverse xs {return
    case xs {
        Null -> Null;
        x:xs -> (reverse xs) `append` (singleton x);
    }
;}

map :: (a -> b) -> List a -> List b;
fn map f xs {return
    case xs {
        Null -> Null;
        x:xs -> f x : map f xs;
    }
;}

filter :: (a -> Bool) -> List a -> List a;
fn filter f xs {return
    case xs {
        Null -> Null;
        x:xs -> if f x then x : filter f xs else filter f xs;
    }
;}
