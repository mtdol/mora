-- free types (`a` here) must be quantified on the left
data List a := 
      Cons val :: a, next :: List a
    | Null
;

-- TODO: if we get function overloading, remove the `l`s from the function
--  names

lsingleton :: a -> List a;
fn lsingleton x {return Cons x Null;}

-- defines `:` as the `cons` operator
op : x xs {return Cons x xs;}
op ++ xs ys {return xs `lappend` ys;}

lappend :: List a -> List a -> List a;
fn lappend xs ys {return
    -- `,` is tuple constructor
    -- `case` is an expression, `Case` is a statement
    case xs, ys {
        Null, ys -> 
            ys;
        (x:xs), ys ->
            Cons x (xs `lappend` ys);
    }
;}

lhead :: List a -> a;
fn lhead xs {
    If xs = Null {error "Cannot head deref Null."}
    Else {return xs.val;}
}

ltail :: List a -> List a;
fn ltail xs {
    If xs = Null {error "Cannot tail deref Null.";}
    Else {return xs.next}
}

lreverse :: List a -> List a;
fn lreverse xs {return
    case xs {
        Null -> Null;
        x:xs -> (lreverse xs) `lappend` (singleton x);
    }
;}

lmap :: (a -> b) -> List a -> List b;
fn lmap f xs {return
    case xs {
        Null -> Null;
        x:xs -> f x : f `lmap` xs;
    }
;}

lfilter :: (a -> Bool) -> List a -> List a;
fn lfilter f xs {return
    case xs {
        Null -> Null;
        x:xs -> if f x then x : f `lfilter` xs else f `lfilter` xs;
    }
;}
