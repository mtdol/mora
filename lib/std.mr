#include <list.mr>

data Maybe a := 
      Yes ({getMaybe} :: a)  
    | No
;
data Either a b := 
      Left ({getLeft} :: a) 
    | Right ({getRight} :: b)
;

-- generic heap reference
data Ref a := Ref ({deref,mutate} :: a);

-- data Bool       := True | False; 

type String     := Array Char;

op @   := printLn;
op ++  := append;
op &&  := and;
op ||  := or;
op ^^  := xor;


-- id :: a -> a;
fn id a {return a;}

--not :: Bool -> Bool;
fn not b {return if b then False else True;}
--and :: Bool -> Bool -> Bool;
fn and b1 b2 {return if b1 then (if b2 then True else False) else False;}
--or :: Bool -> Bool -> Bool;
fn or b1 b2 {return if b1 then True else (if b2 then True else False);}
--xor :: Bool -> Bool -> Bool;
fn xor b1 b2 {return b1 /= b2;}

fn odd n {return n % 2 = 1;}
fn even n {return n % 2 = 0;}

-- in place map
--map :: (a -> b) -> Array a -> Void;
fn map f a {
    dec i;
    i <- 0;

    While (i /= length a) {
        a ! i <- f (a ! i);
        i +< 1;
    }
}

-- map and generate a new array
-- "generative" map
--map :: (a -> b) -> Array a -> Array b;
fn gmap f a {
    dec i, ret;
    i <- 0;
    ret <- Array (length a);

    While (i /= length a) {
        ret ! i <- f (a ! i);
        i +< 1;
    }

    return ret;
}

-- applies a function to an array without modifying it.
-- "void" map
--vmap :: (a -> b) -> Array a -> Void;
fn vmap f a {
    dec i;
    i <- 0;

    While (i /= length a) {
        f $ a ! i;
        i +< 1;
    }
}

--append :: Array a -> Array a -> Array a;
fn append a1 a2 {
    dec ret, i;
    ret <- Array (length a1 + length a2);
    i <- 0;

    While (i /= length a1) {
        ret ! i <- a1 ! i;
        i     +< 1;
    }

    While (i /= length ret) {
        ret ! i <- a2 ! (i - length a1);
        i     +< 1;
    }

    return ret;
}

--filter :: (a -> Bool) -> Array a -> Array a;
fn filter f a {
    dec ret, i, reti, ret2;
    ret     <- Array $ length a;
    i       <- 0;
    reti    <- 0;

    While (i /= length a) {
        If (f $ a ! i) {
            ret ! reti <- a ! i;
            reti     +< 1;
        }
        i +< 1;
    }

    -- shrink array
    i <- 0;
    ret2 <- Array reti;
    While (i /= reti) {ret2 ! i <- ret ! i; i +< 1;}

    return ret2;
}

--slice :: Array a -> (Int, Int) -> Array a
fn slice a is {
    dec ret, reti, i1, i2;
    i1 <- fst is;
    i2 <- snd is;
    reti <- 0;

    If (i1 > i2 || (i2 - i1) > length a) {
        error $ "Invalid range for slice: [" 
            ++ show i1 ++ " " ++ show i2 ++ ")";
    }
    ret <- Array (i2 - i1);
    
    While (i1 /= i2) {
        ret ! reti <- a ! i1;
        reti  +< 1;
        i1 +< 1;
    }

    return ret;
}


--
--- IO
--

-- TODO: might go away, basically for testing
fn retPrint v {printLn v; return v;}

--print :: a -> Void;
fn print v {printChar `vmap` show v;}
--printLn :: a -> Void;
fn printLn v {print v; printChar '\n';}

fn put s {printChar `vmap` s;}
fn putLn s {printChar `vmap` s; printChar '\n';}

--
--- Structures, Tuples
--

fn fst tp {return
    case tp {
        (x,_) -> x;
    }
;}

fn snd tp {return
    case tp {
        (_,y) -> y;
    }
;}

-- uncurry :: (a -> b -> c) -> (a, b) -> c;
fn uncurry f xy {return
    f (fst xy) (snd xy)
;}

-- curry :: ((a, b) -> c) -> a -> b -> c;
fn curry f x y {return
    f (x,y)
;}

fn main args {
    lprint $ lfilter odd $ 1:2:3:4:5:Null;
    printChar '\n';

    dec v;
    v <- if length args = 0 then No else Yes $ args ! 0;

    Case v {
        Yes s -> {putLn s;}
        No -> {putLn "nope";}
    }

    @ fst (1,2);
    @ snd (1,2);

    @ case [1,2,3] {
        [x,y,3] -> x-y; 
    };

    putLn $ case "abc" {
        a@[x,y,'c'] -> [y,x] `append` a; 
    };

    putLn $ case "abc" {
        s@"aba" -> ['a'] ++ s;
        s@"abb" -> ['b'] ++ s;
        s@"abc" -> ['c'] ++ s;
        s@"abd" -> ['d'] ++ s;
    };

    dec xs;
    xs <- 1:2:3:Null;
    -- changes `1:2:3:Null` to `1:2:4:Null`
    lsetVal (lgetNext $ lgetNext xs) 4; 
    lprint xs;
    putLn "";

    -- changes `1:2:4:Null` to `1:2:5:Null`
    Case xs {
        1:2:x -> {lsetVal x 5;}
    }
    lprint xs;
    putLn "";

    return 0;
}
