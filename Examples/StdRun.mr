-- tests various common sense features
fn main args {
    assert (leq eq) (1:3:5:Null) $ lfilter odd $ 1:2:3:4:5:Null;

    dec v;
    v <- if length args = 0 then No else Yes $ args ! 0;
    
    dec t;
    Case v {
        Yes s -> {t <- "Yes args: " ++ show s;}
        No -> {t <- "No args";}
    }
    putLn t; t <- "";

    assert eq 1 $ fst (1,2);
    assert eq 2 $ snd (1,2);

    assert eq (-1) $ case [1,2,3] {
        [x,y,3] -> x-y; 
    };

    assert streq "baabc" $ case "abc" {
        a@[x,y,'c'] -> [y,x] `append` a; 
    };

    assert streq "cabc" $ case "abc" {
        s@"aba" -> ['a'] ++ s;
        s@"abb" -> ['b'] ++ s;
        s@"abc" -> ['c'] ++ s;
        s@"abd" -> ['d'] ++ s;
    };

    dec xs;
    xs <- 1:2:3:Null;
    -- changes `1:2:3:Null` to `1:2:4:Null`
    lsetVal (lgetNext $ lgetNext xs) 4; 
    assert (leq eq) (1:2:4:Null) $ xs;

    -- changes `1:2:4:Null` to `1:2:5:Null`
    Case xs {
        1:2:x -> {lsetVal x 5;}
    }
    assert (leq eq) (1:2:5:Null) $ xs;

    return 0;
}

fn eq x y -> x = y;
fn streq x y {
    dec i <- 0;
    If length x /= length y {return False;}
    While i /= length x {
        If x ! i /= y ! i {return False;}
        i +< 1;
    }
    return True;
}
fn leq cmp xs ys -> case (xs,ys) {
    (Null, Null) -> True;
    (x:xs,y:ys) -> x `cmp` y && leq cmp xs ys;
    _ -> False;
};
fn assert cmp v1 v2 {
    If v1 `cmp` v2 {
        putLn $ "Good";
    } Else {putLn $ "Bad";}
}
