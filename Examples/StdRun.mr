-- tests various common-sense features
fn main args {
    assert (leq eq) (1:3:5:Null) $ lfilter odd $ 1:2:3:4:5:Null;

    assert eq 3 $ llength $ 1:2:3:Null;
    assert eq 1 $ llength $ 1:Null;
    assert eq 0 $ llength $ Null;

    assert (leq eq) (2:3:4:Null) $ add1 `lgmap` (1:2:3:Null);

    dec v;
    v <- if length args = 0 then No else Yes $ args ! 0;
    
    dec t;
    Case v {
        Yes s -> {t <- "Yes args: " ++ show s;}
        No -> {t <- "No args";}
    }
    putLn t; t <- "";

    assert eq 1 $ fst (1,2);
    assert eq 2 $ snd (1,2);

    assert eq (-1) $ case [1,2,3] {
        [x,y,3] -> x-y; 
    };

    assert strEq "baabc" $ case "abc" {
        a@[x,y,'c'] -> [y,x] `append` a; 
    };

    assert strEq "cabc" $ case "abc" {
        s@"aba" -> ['a'] ++ s;
        s@"abb" -> ['b'] ++ s;
        s@"abc" -> ['c'] ++ s;
        s@"abd" -> ['d'] ++ s;
    };

    dec xs;
    xs <- 1:2:3:Null;
    -- changes `1:2:3:Null` to `1:2:4:Null`
    lsetVal (lgetNext $ lgetNext xs) 4; 
    assert (leq eq) (1:2:4:Null) $ xs;

    -- changes `1:2:4:Null` to `1:2:5:Null`
    Case xs {
        1:2:x -> {lsetVal x 5;}
    }
    assert (leq eq) (1:2:5:Null) $ xs;

    assert eq 4 $ 
        foldr (\x acc -> acc - x) 10 [1,2,3];
    assert eq 4 $ 
        foldl (\x acc -> acc - x) 10 [1,2,3];

    assert strEq "efcdab" $ 
        foldr (\x acc -> acc++x) "" ["ab","cd","ef"]; 
    assert strEq "abcdef" $ 
        foldl (\x acc -> acc++x) "" ["ab","cd","ef"]; 

    assert eq 4 $ 
        lfoldr (\x acc -> acc - x) 10 $ 1:2:3:Null;
    assert eq 4 $ 
        lfoldl (\x acc -> acc - x) 10 $ 1:2:3:Null;

    assert strEq "efcdab" $ 
        lfoldr (\x acc -> acc++x) "" $ "ab":"cd":"ef":Null; 
    assert strEq "abcdef" $ 
        lfoldl (\x acc -> acc++x) "" $ "ab":"cd":"ef":Null; 

    return 0;
}

fn eq x y -> x = y;
fn arrEq cmp x y {
    dec i <- 0;
    If length x /= length y {return False;}
    While i /= length x {
        If not $ (x ! i) `cmp` (y ! i) {return False;}
        i +< 1;
    }
    return True;
}

fn strEq x y -> arrEq eq x y;

fn leq cmp xs ys -> case (xs,ys) {
    (Null, Null) -> True;
    (x:xs,y:ys) -> x `cmp` y && leq cmp xs ys;
    _ -> False;
};

fn assert cmp v1 v2 {
    If v1 `cmp` v2 {
        putLn $ "Good";
    } Else {putLn $ "Bad";}
}
